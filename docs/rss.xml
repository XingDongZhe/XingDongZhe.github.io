<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0"><channel><title>Blog Title</title><link>https://xingdongzhe.github.io</link><description>Blog description</description><copyright>Blog Title</copyright><docs>http://www.rssboard.org/rss-specification</docs><generator>python-feedgen</generator><image><url>https://github.githubassets.com/favicons/favicon.svg</url><title>avatar</title><link>https://xingdongzhe.github.io</link></image><lastBuildDate>Sun, 31 Mar 2024 11:19:01 +0000</lastBuildDate><managingEditor>Blog Title</managingEditor><ttl>60</ttl><webMaster>Blog Title</webMaster><item><title>asyncio core code with simple implement</title><link>https://xingdongzhe.github.io/post/asyncio%20core%20code%20with%20simple%20implement.html</link><description>### asyncio 的重要组成部分&#13;
&#13;
- 多路复用(select/poll/epoll)&#13;
- 回调函数&#13;
- Eventloop(核心组件)&#13;
- Future&#13;
- Task&#13;
- Handle(TimerHandle)&#13;
&#13;
### 异步编程模型&#13;
&#13;
- 事件循环 + 回调&#13;
&#13;
### Eventloop(事件循环)是什么&#13;
&#13;
- 一句话: 事件循环就一个循环，一个无限循环&#13;
&#13;
### Eventloop(事件循环)的作用是什么&#13;
&#13;
- 事件循环是 asyncio的心脏，负责处理 IO ，安排协程和回调函数的执行计划，即保存上下文、切换运行协程、恢复上下文、重新运行协程&#13;
&#13;
- 事件循环有三个重要组成部分&#13;
&#13;
  - IO 处理机制，多路复用&#13;
  - 任务队列&#13;
  - 待安排队列&#13;
&#13;
  ```python&#13;
  # base_event.py&#13;
  class BaseEventLoop:&#13;
    def __init__(self):&#13;
      self._ready = deque() # List[Handle]&#13;
      self._scheduled = []  # List[TimerHandl]，是一个最小二叉堆&#13;
      self._selector = Selector()&#13;
      &#13;
    def run_until_complete(self, future):&#13;
      pass&#13;
    &#13;
    def create_task(self, coro):&#13;
      pass&#13;
    &#13;
    def _run_once(self):&#13;
      pass&#13;
    &#13;
    def call_soon(self, callback, *args):&#13;
      pass&#13;
  ```&#13;
&#13;
  &#13;
&#13;
- asyncio 中的协程是如何串联起来的&#13;
&#13;
  `Task._step 和 Task._wakeup`&#13;
&#13;
- 基于生成器的协程, `yield`&#13;
&#13;
  - 可以保存自己的上下文，如运行状态，运行的值&#13;
&#13;
  - 让出控制权&#13;
  - 产出一个值&#13;
  - 接收一个值&#13;
  - 可以多次重新进入从上次让出控制权的地方&#13;
&#13;
- 原生协程, `__await__`或者`__iter__`&#13;
&#13;
- async 是一个关键字，async def 定义的类型还是一个function类型，只有当它被调用时才返回一个协程对象&#13;
   `async def` 跟`def`定义的方法在没被调用时没有任何区别，不必看得很神秘，它也可以有`return`语句&#13;
&#13;
- asyncio底层运行都是普通函数，每轮循环只会执行当前循环的就绪队列中的任务(函数)&#13;
   &#13;
- Async 和 await 只是语法糖，源码底下也是还是用了生成器, 是遇到`yield`关键字才会挂起&#13;
&#13;
  ```python&#13;
  def __iter__(self):&#13;
    if not self.done():&#13;
      self._asyncio_future_blocking = True&#13;
      yield self  # This tells Task to wait for completion.&#13;
      assert self.done(), "yield from wasn't used with future"&#13;
      return self.result()  # May raise too.&#13;
    &#13;
  # PY35 = sys.version_info &gt;= (3, 5)&#13;
  if compat.PY35:&#13;
  		__await__ = __iter__ # make compatible with 'await' expression&#13;
  ```&#13;
&#13;
  &#13;
&#13;
- 生成器的方法&#13;
&#13;
  - send&#13;
  - throw&#13;
  - close&#13;
  - \_\_next\_\_(next)&#13;
&#13;
- 生成器完结异常:&#13;
&#13;
  `StopIteration`&#13;
&#13;
- Event_loop&#13;
&#13;
  ```python&#13;
  # base_event.py&#13;
  class BaseEventLoop:&#13;
    def __init__(self):&#13;
      self._ready = deque() # List[Handle]&#13;
      self._scheduled = []  # List[TimerHandl]，是一个最小二叉堆&#13;
      self._selector = Selector()&#13;
      &#13;
    def run_until_complete(self, future):&#13;
      future = tasks.ensure_future(future, loop=self)&#13;
      future.add_done_callback(_run_until_complete_cb)&#13;
      self.run_forever()&#13;
      &#13;
      &#13;
    def run_forever():&#13;
      self._run_once()&#13;
    &#13;
    def create_task(self, coro):&#13;
       task = tasks.Task(coro, loop=self)&#13;
       return task&#13;
    &#13;
    def _run_once(self):&#13;
      event_list = self._selector.select(timeout)&#13;
      self._process_events(event_list)&#13;
      ntodo = len(self._ready)&#13;
      for i in range(ntodo):&#13;
        handle = self._ready.popleft()&#13;
        handle._run()&#13;
    &#13;
    def call_soon(self, callback, *args):&#13;
      handle = events.Handle(callback, args, self)&#13;
      self._ready.append(handle)&#13;
      return handle&#13;
    &#13;
    def call_at(self, when, callback, *args):&#13;
      timer = events.TimerHandle(when, callback, args, self)&#13;
      heapq.heappush(self._scheduled, timer)&#13;
      timer._scheduled = True&#13;
      return timer&#13;
  ```&#13;
&#13;
  &#13;
&#13;
- Future&#13;
&#13;
  ```python&#13;
  # futures.py&#13;
  class Future:&#13;
    def __init__(self, loop=None):&#13;
      self._loop = loop&#13;
      self._callback = [] # List[Function]&#13;
      &#13;
    def set_result(self, result):&#13;
       self._result = result&#13;
       self._state = _FINISHED&#13;
       for callback in self.callbacks:&#13;
          self._loop.call_soon(callback, self)&#13;
          &#13;
    def __iter__(self):&#13;
    	if not self.done():&#13;
      	self._asyncio_future_blocking = True&#13;
        yield self  # This tells Task to wait for completion.&#13;
      assert self.done(), "yield from wasn't used with future"&#13;
      return self.result()  # May raise too.&#13;
  ```&#13;
&#13;
  &#13;
&#13;
- Task&#13;
&#13;
  ```python&#13;
  # tasks.py&#13;
  class Task(Future):&#13;
    def __init__(self, coro, *, loop=None):&#13;
      super().__init__(self, loop)&#13;
      self._coro = coro&#13;
      self._loop.call_soon(self._step)&#13;
      &#13;
  	def _step(self, exc=None):&#13;
      coro = self._coro&#13;
      try:&#13;
      	result = coro.send(None)&#13;
      except StopIteration as exc:&#13;
        self.set_result(exc.value)&#13;
      else:&#13;
        result.add_done_callback(self._wakeup)&#13;
      &#13;
    &#13;
    def _wakeup(self, future):&#13;
      self._step()&#13;
  ```&#13;
&#13;
- Handle&#13;
&#13;
  ```python&#13;
  # events.py&#13;
  class Handle:&#13;
      def __init__(self, callback, args, loop):&#13;
          self._loop = loop&#13;
          self._callback = callback&#13;
          self._args = args&#13;
          &#13;
  		def _run(self):&#13;
        self._callback(*self._args)&#13;
      &#13;
      &#13;
  class TimerHandle(Handle):&#13;
      def __init__(self, when, callback, args, loop):&#13;
          assert when is not None&#13;
          super().__init__(callback, args, loop)&#13;
          self._when = when&#13;
          self._scheduled = False&#13;
  ```&#13;
&#13;
  &#13;
&#13;
### 代码执行流程&#13;
&#13;
```python&#13;
import asyncio&#13;
&#13;
&#13;
async def cor():&#13;
    print('enter cor ...')&#13;
    await asyncio.sleep(2)&#13;
    print('exit cor ...')&#13;
    &#13;
    return 'cor'&#13;
&#13;
loop = asyncio.get_event_loop()&#13;
task = loop.create_task(cor())&#13;
rst = loop.run_until_complete(task)&#13;
print(rst)&#13;
```&#13;
&#13;
```python&#13;
class Task(futures.Future):&#13;
    &#13;
    ...&#13;
    &#13;
    def _step(self, exc=None):&#13;
        """&#13;
        _step方法可以看做是task包装的coroutine对象中的代码的直到yield的前半部分逻辑&#13;
        """&#13;
        ...&#13;
        try:&#13;
            if exc is None:&#13;
                &#13;
                # 1.关键代码&#13;
                result = coro.send(None)&#13;
            else:&#13;
                result = coro.throw(exc)&#13;
        # 2. coro执行完毕会抛出StopIteration异常&#13;
        except StopIteration as exc:&#13;
            if self._must_cancel:&#13;
                # Task is cancelled right before coro stops.&#13;
                self._must_cancel = False&#13;
                self.set_exception(futures.CancelledError())&#13;
            else:&#13;
                # result为None时，调用task的callbasks列表中的回调方法，在调用loop.run_until_complite，结束loop循环&#13;
                self.set_result(exc.value)&#13;
        except futures.CancelledError:&#13;
            super().cancel()  # I.e., Future.cancel(self).&#13;
        except Exception as exc:&#13;
            self.set_exception(exc)&#13;
        except BaseException as exc:&#13;
            self.set_exception(exc)&#13;
            raise&#13;
        # 3. result = coro.send(None)不抛出异常&#13;
        else:&#13;
            # 4. 查看result是否含有_asyncio_future_blocking属性&#13;
            blocking = getattr(result, '_asyncio_future_blocking', None)&#13;
            if blocking is not None:&#13;
                # Yielded Future must come from Future.__iter__().&#13;
                if result._loop is not self._loop:&#13;
                    self._loop.call_soon(&#13;
                        self._step,&#13;
                        RuntimeError(&#13;
                            'Task {!r} got Future {!r} attached to a '&#13;
                            'different loop'.format(self, result)))&#13;
                &#13;
                elif blocking:&#13;
                    if result is self:&#13;
                        self._loop.call_soon(&#13;
                            self._step,&#13;
                            RuntimeError(&#13;
                                'Task cannot await on itself: {!r}'.format(&#13;
                                    self)))&#13;
                    # 4.1. 如果result是一个future对象时，blocking会被设置成true&#13;
                    else:&#13;
                        result._asyncio_future_blocking = False&#13;
                        # 把_wakeup回调函数设置到此future对象中，当此future对象调用set_result()方法时，就会调用_wakeup方法&#13;
                        result.add_done_callback(self._wakeup)&#13;
                        self._fut_waiter = result&#13;
                        if self._must_cancel:&#13;
                            if self._fut_waiter.cancel():&#13;
                                self._must_cancel = False&#13;
                else:&#13;
                    self._loop.call_soon(&#13;
                        self._step,&#13;
                        RuntimeError(&#13;
                            'yield was used instead of yield from '&#13;
                            'in task {!r} with {!r}'.format(self, result)))&#13;
            # 5. 如果result是None，则注册task._step到loop对象中去，在下一轮_run_once中被回调&#13;
            elif result is None:&#13;
                # Bare yield relinquishes control for one event loop iteration.&#13;
                self._loop.call_soon(self._step)&#13;
&#13;
            # --------下面的代码可以暂时不关注了--------&#13;
            elif inspect.isgenerator(result):&#13;
                # Yielding a generator is just wrong.&#13;
                self._loop.call_soon(&#13;
                    self._step,&#13;
                    RuntimeError(&#13;
                        'yield was used instead of yield from for '&#13;
                        'generator in task {!r} with {}'.format(&#13;
                            self, result)))&#13;
            else:&#13;
                # Yielding something else is an error.&#13;
                self._loop.call_soon(&#13;
                    self._step,&#13;
                    RuntimeError(&#13;
                        'Task got bad yield: {!r}'.format(result)))&#13;
        finally:&#13;
            self.__class__._current_tasks.pop(self._loop)&#13;
            self = None  # Needed to break cycles when an exception occurs.&#13;
&#13;
    def _wakeup(self, future):&#13;
        try:&#13;
            future.result()&#13;
        except Exception as exc:&#13;
            # This may also be a cancellation.&#13;
            self._step(exc)&#13;
        else:&#13;
            &#13;
            # 这里是关键代码，上次的_step()执行到第一次碰到yield的地方挂住了，此时再次执行_step(),&#13;
            # 也就是再次执行 result = coro.send(None) 这句代码，也就是从上次yield的地方继续执行yield后面的逻辑&#13;
            self._step()&#13;
        self = None  # Needed to break cycles when an exception occurs.&#13;
```&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
`run_until_complete()` --&gt; `run_forever()` --&gt; `_run_once()`，重点看`_run_once`这个方法的执行&#13;
&#13;
此时:&#13;
&#13;
- `cor`协程还未开始执行&#13;
- `loop._ready = [handle(task._step)]`，`loop._scheduled = [], task._callbacks=[_run_until_complete_cb]`&#13;
&#13;
#### 第一轮`_run_once()`的调用执行开始&#13;
&#13;
此时:&#13;
&#13;
- `cor`协程的执行流程挂起在`sleep`协程的中产生的新`Future`对象的`__iter__`方法的`yield`处&#13;
- 新`Future`对象的`_callbacks = [task._wakeup,]`&#13;
- `loop._scheduled=[handle(delay_2s__set_result_unless_cancelled)]`，`loop._ready=[]`&#13;
&#13;
#### 第二轮`_run_once()`的调用执行开始&#13;
&#13;
此时:&#13;
&#13;
- `cor`协程的执行流程挂起在`sleep`协程的中产生的新`Future`对象的`__iter__`方法的`yield`处。</description><guid isPermaLink="true">https://xingdongzhe.github.io/post/asyncio%20core%20code%20with%20simple%20implement.html</guid><pubDate>Sun, 31 Mar 2024 11:18:16 +0000</pubDate></item><item><title>Docs Test</title><link>https://xingdongzhe.github.io/post/Docs%20Test.html</link><description>- Docs Test。</description><guid isPermaLink="true">https://xingdongzhe.github.io/post/Docs%20Test.html</guid><pubDate>Sun, 31 Mar 2024 11:16:10 +0000</pubDate></item></channel></rss>